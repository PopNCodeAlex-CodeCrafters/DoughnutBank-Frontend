# Implementation

## Contact Me

Feel free to **contact me** at [alex99_pop@yahoo.com](mailto:alex99_pop@yahoo.com) so that I can explain potential ambiguities

## Workflow

You are prompted with a login page so that you can enter your bank account(email and password as credentials). After login a a mocked purchase page is displayed. You can simulate placing an order by pressing 'Purchase'. As a security measure you'll receive a OTP that you need to input it in the popup that appears. If OTP is correct and transaction succeeds an check animation plays.

## Security

HTTPS is put in place so that the transmission of credentials and OTP is secure and encrypted. There is a warning because the certificates are self-signed. Email and password are hashed and saved in cookies. With each request the credentials are sent in the header to the backend because the backend has an authorization filter (that check for credentials) on the OTP related endpoints. There is also an API key that is required no matter the endpoint the client tries to reach (checked by a middleware).

I tried to also use AES encryption on OTP. For selecting a key for AES I tried DiffieHellman algo which works in case the encryption and decryption happens in backend/frontend (as shown by tests).
The thing that did not work was having the 'public key' of client (generated by DiffieHellman) accepted by the backend in the process of creating the 'shared key'. I guess that is because different libraries (cause of the different programming language) create these keys slightly differently. Although it is not working exchanging the keys, the functions required for this encryption/decryption are completely implemented

OTP has an expirationTime and this is taken into consideration when the OTP is checked on the backend. Credentials and OTP are stored in the database (password is hashed in the database, as OTP should be too, it just slipped me).

# Make it work

Create in frontend in the root folder `.env` (fill in the env variables as shown by `.env.model`).

Create `appsettings.Development.json` and fill it as such

```json
{
  "Encryption": "boolean", //should be false so it skips DiffieHellman encryption which is not working
  "Authentication": {
    "ApiKey": "static_api_key" //generate it manually, should be here and also in .env (frontend)
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "server=ip;database=database_name;uid=user;pwd=password;"
  }
}
```

# Technical Challenge

## The problem

Develop a system that can generate a one-time password for a banking application. The OTP system must be secure, efficient, and user-friendly to enhance the user experience and protect customers' data.

## Business Requirements

1. The OTP system must be secure to protect the confidential data of the customers. It must ensure that OTPs are generated randomly and are not predictable. Encryption during transmission of the OTPs should also be ensured.
2. The OTPs should be time-bound. Once generated, an OTP should not be valid indefinitely. The system should automatically invalidate the OTP after a certain period of time that can be easily customized.
3. The OTP input interface should be user-friendly. It should allow users to input the OTP easily without any confusion.
4. The system should have good error handling. It should inform the user about any issues in a clear and understandable way.
5. For the purpose of this exercise, the user should receive the OTP in a toast message that will be visible as long as the OTP is valid.

## Techincal requirements

1. The solution must be a web application developed on the latest .NET framework.
2. For the frontend part you can use any javascript framework you want.
3. Unit tests must be performed with a test coverage of at least 70%.

## Evaluation

Your solution will be evaluated based on coding and testability standards, naming conventions, project structure and the meeting of requirements. It must be uploaded in a public github repository that can be accessed by us for validation.
